---
date: "2019-05-10T10:23:48+08:00"
publishdate: "2019-05-10"
lastmod: "2019-05-10"
draft: false
title: "JNI调用"
tags: ["java"]
series: ["JNI调用"]
categories: ["Java基础"]
##img: "images/blog/2018-08/test4.jpg"
toc: true
---

## Java JNI(Java Native Interface)调用C代码  linux
***
#### 前言
- 之前在对接脱机终端动态二维码验签，需要在javaWeb中调用到C语言封装的动态so类库。本次记录是对本次经验的总结 java调用C代码总共分为5步  

***
1. 在**com.gw.web.hpay.util.encrypt**这个包下创建一个java类**TestUseC.java**,编写了一个native方法**getNumber()**  

``` java
代码如下:
package com.gw.web.hpay.util.encrypt;

/**
 * @author Shugege
 * @Discription 调用C代码
 * @Data 2018/9/28
 * @Version 1.0.0
 */
public class TestUseC {
    static {
        /* 1. load */
        System.loadLibrary("native"); /*libnative.so*/
    }
    public native int getNumber();
    public static  void main( String args[] )
    {
        /* 2. java <--> C */

        /* 3. call */
        final TestUseC c = new TestUseC();
        System.out.println( c.getNumber() );
    }
}

```  

2.通过 **javah** 生成C语言的头文件例如:**TestUseC.java**的全路径为：**D:\pay\dev\web\gw-web-hpay\src\main\java\com\gw\web\hpay\util\encrypt\TestUseC.java** ,javah应该在包的**根路径**执行

***

```
D:\pay\dev\web\gw-web-hpay\src\main\java\com\gw\web\hpay\util\encrypt>cd ..

D:\pay\dev\web\gw-web-hpay\src\main\java\com\gw\web\hpay\util>cd ..

D:\pay\dev\web\gw-web-hpay\src\main\java\com\gw\web\hpay>cd ..

D:\pay\dev\web\gw-web-hpay\src\main\java\com\gw\web>cd ..

D:\pay\dev\web\gw-web-hpay\src\main\java\com\gw>cd ..

D:\pay\dev\web\gw-web-hpay\src\main\java\com>cd ..

D:\pay\dev\web\gw-web-hpay\src\main\java>javah com.gw.web.hpay.util.encrypt.TestUseC
```
**生成结果如下 （文件名com_gw_web_hpay_util_encrypt_TestUseC.h）**： 
``` C
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_gw_web_hpay_util_encrypt_TestUseC */

#ifndef _Included_com_gw_web_hpay_util_encrypt_TestUseC
#define _Included_com_gw_web_hpay_util_encrypt_TestUseC
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_gw_web_hpay_util_encrypt_TestUseC
 * Method:    getNumber
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_gw_web_hpay_util_encrypt_TestUseC_getNumber
  (JNIEnv *, jobject);//类型(jint) Java_package_Class_method

#ifdef __cplusplus
}
#endif
#endif
```
**编写c语言代码（TestUseC.c）:**  
```
#include "com_gw_web_hpay_util_encrypt_TestUseC.h"
 
JNIEXPORT jint JNICALL Java_com_gw_web_hpay_util_encrypt_TestUseC_getNumber
  (JNIEnv *env, jobject obj) //记得给参数提供别名 如*env obj
{
    
    return 66;
}

```
**Class**对应java的全类名：**com.gw.web.hpay.util.encrypt.TestUseC**  
返回类型(jint==>int ) Java_package_Class_method  
3. 将生成的XXX.c,xxx.h文件上传到linux服务器  
**Linux**下生成共享库,分为两步:  
    1. 编译并生成.o文件,命令行如下:**echo $JAVA_HOME**获取JDK路径如：/usr/java/jdk1.7.0
    2. 生成动态库文件**libnative.so** 如下图所示:
```
#-fPIC; 代表编译为位置独立的代码，满足了不同的进程对所加载动态库的共享;
#-c; 表示只编译源文件但不链接;
#$<; 表示所搜索到与第一个相匹配的文件，即第一个[.c]文件；
#-o; 指定输出文件名;
#$@; 与[.c]文件相对应的[.o]文件；
#-I.; 需用到的头文件在本目录中找.
#-shared;生成动态库

---------------------
#命令1 从 /usr/java/jdk1.7.0/include 中寻找头文件jni.h 
而jni.h需要从 /usr/java/jdk1.7.0/include/linux/ 中找到jni_md.h的头文件，所以有了如下命令
gcc -I /usr/java/jdk1.7.0/include -I /usr/java/jdk1.7.0/include/linux/ -fPIC -c TestUseC.c
#命令2 
gcc -shared -fPIC -o libnative.so TestUseC.o
```
4. 将文件放入 **libnative.so** 放入web应用 **WEB-INF** 下。(**java -XshowSettings:properties**可以查看java环境配置信息)System.loadLibrary()方法会从  
 1)和jre相关的一些目录  
 2)程序当前目录(echo $PATH可查看)  
 3)Windows目录   
 4)系统目录(system32)   
 5)系统环境变量path指定目录  
中查找并加载动态库
5.  打包放入tomcat启动tomcat并访问应用结果如下:  
![JNI支付结果](https://raw.githubusercontent.com/shuerwa/newRepositoryReal/master/jniResult.png)
#### 总结
在对接过程中，如果对方直接提供*.so文件的动态类库，可以通过nm命令查看文件中的类名，方法名方便你编写java类。

    

## 版本控制

| Version | Action            | Time       |
| ------- | ----------------- | ---------- |
| 1.0     | Init 从有道云笔记移出 | 2019-05-10 |

